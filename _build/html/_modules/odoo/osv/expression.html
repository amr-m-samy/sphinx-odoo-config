<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>odoo.osv.expression &mdash; Amr  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Amr
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">odoo</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Amr</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../odoo.html">odoo</a></li>
      <li class="breadcrumb-item active">odoo.osv.expression</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for odoo.osv.expression</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Part of Odoo. See LICENSE file for full copyright and licensing details.</span>

<span class="sd">&quot;&quot;&quot; Domain expression processing</span>

<span class="sd">The main duty of this module is to compile a domain expression into a</span>
<span class="sd">SQL query. A lot of things should be documented here, but as a first</span>
<span class="sd">step in the right direction, some tests in test_expression.py</span>
<span class="sd">might give you some additional information.</span>

<span class="sd">For legacy reasons, a domain uses an inconsistent two-levels abstract</span>
<span class="sd">syntax (domains are regular Python data structures). At the first</span>
<span class="sd">level, a domain is an expression made of terms (sometimes called</span>
<span class="sd">leaves) and (domain) operators used in prefix notation. The available</span>
<span class="sd">operators at this level are &#39;!&#39;, &#39;&amp;&#39;, and &#39;|&#39;. &#39;!&#39; is a unary &#39;not&#39;,</span>
<span class="sd">&#39;&amp;&#39; is a binary &#39;and&#39;, and &#39;|&#39; is a binary &#39;or&#39;.  For instance, here</span>
<span class="sd">is a possible domain. (&lt;term&gt; stands for an arbitrary term, more on</span>
<span class="sd">this later.)::</span>

<span class="sd">    [&#39;&amp;&#39;, &#39;!&#39;, &lt;term1&gt;, &#39;|&#39;, &lt;term2&gt;, &lt;term3&gt;]</span>

<span class="sd">It is equivalent to this pseudo code using infix notation::</span>

<span class="sd">    (not &lt;term1&gt;) and (&lt;term2&gt; or &lt;term3&gt;)</span>

<span class="sd">The second level of syntax deals with the term representation. A term</span>
<span class="sd">is a triple of the form (left, operator, right). That is, a term uses</span>
<span class="sd">an infix notation, and the available operators, and possible left and</span>
<span class="sd">right operands differ with those of the previous level. Here is a</span>
<span class="sd">possible term::</span>

<span class="sd">    (&#39;company_id.name&#39;, &#39;=&#39;, &#39;OpenERP&#39;)</span>

<span class="sd">The left and right operand don&#39;t have the same possible values. The</span>
<span class="sd">left operand is field name (related to the model for which the domain</span>
<span class="sd">applies).  Actually, the field name can use the dot-notation to</span>
<span class="sd">traverse relationships.  The right operand is a Python value whose</span>
<span class="sd">type should match the used operator and field type. In the above</span>
<span class="sd">example, a string is used because the name field of a company has type</span>
<span class="sd">string, and because we use the &#39;=&#39; operator. When appropriate, a &#39;in&#39;</span>
<span class="sd">operator can be used, and thus the right operand should be a list.</span>

<span class="sd">Note: the non-uniform syntax could have been more uniform, but this</span>
<span class="sd">would hide an important limitation of the domain syntax. Say that the</span>
<span class="sd">term representation was [&#39;=&#39;, &#39;company_id.name&#39;, &#39;OpenERP&#39;]. Used in a</span>
<span class="sd">complete domain, this would look like::</span>

<span class="sd">    [&#39;!&#39;, [&#39;=&#39;, &#39;company_id.name&#39;, &#39;OpenERP&#39;]]</span>

<span class="sd">and you would be tempted to believe something like this would be</span>
<span class="sd">possible::</span>

<span class="sd">    [&#39;!&#39;, [&#39;=&#39;, &#39;company_id.name&#39;, [&#39;&amp;&#39;, ..., ...]]]</span>

<span class="sd">That is, a domain could be a valid operand. But this is not the</span>
<span class="sd">case. A domain is really limited to a two-level nature, and can not</span>
<span class="sd">take a recursive form: a domain is not a valid second-level operand.</span>

<span class="sd">Unaccent - Accent-insensitive search</span>

<span class="sd">OpenERP will use the SQL function &#39;unaccent&#39; when available for the</span>
<span class="sd">&#39;ilike&#39; and &#39;not ilike&#39; operators, and enabled in the configuration.</span>
<span class="sd">Normally the &#39;unaccent&#39; function is obtained from `the PostgreSQL</span>
<span class="sd">&#39;unaccent&#39; contrib module</span>
<span class="sd">&lt;http://developer.postgresql.org/pgdocs/postgres/unaccent.html&gt;`_.</span>

<span class="sd">.. todo: The following explanation should be moved in some external</span>
<span class="sd">         installation guide</span>

<span class="sd">The steps to install the module might differ on specific PostgreSQL</span>
<span class="sd">versions.  We give here some instruction for PostgreSQL 9.x on a</span>
<span class="sd">Ubuntu system.</span>

<span class="sd">Ubuntu doesn&#39;t come yet with PostgreSQL 9.x, so an alternative package</span>
<span class="sd">source is used. We use Martin Pitt&#39;s PPA available at</span>
<span class="sd">`ppa:pitti/postgresql</span>
<span class="sd">&lt;https://launchpad.net/~pitti/+archive/postgresql&gt;`_.</span>

<span class="sd">.. code-block:: sh</span>

<span class="sd">    &gt; sudo add-apt-repository ppa:pitti/postgresql</span>
<span class="sd">    &gt; sudo apt-get update</span>

<span class="sd">Once the package list is up-to-date, you have to install PostgreSQL</span>
<span class="sd">9.0 and its contrib modules.</span>

<span class="sd">.. code-block:: sh</span>

<span class="sd">    &gt; sudo apt-get install postgresql-9.0 postgresql-contrib-9.0</span>

<span class="sd">When you want to enable unaccent on some database:</span>

<span class="sd">.. code-block:: sh</span>

<span class="sd">    &gt; psql9 &lt;database&gt; -f /usr/share/postgresql/9.0/contrib/unaccent.sql</span>

<span class="sd">Here :program:`psql9` is an alias for the newly installed PostgreSQL</span>
<span class="sd">9.0 tool, together with the correct port if necessary (for instance if</span>
<span class="sd">PostgreSQL 8.4 is running on 5432). (Other aliases can be used for</span>
<span class="sd">createdb and dropdb.)</span>

<span class="sd">.. code-block:: sh</span>

<span class="sd">    &gt; alias psql9=&#39;/usr/lib/postgresql/9.0/bin/psql -p 5433&#39;</span>

<span class="sd">You can check unaccent is working:</span>

<span class="sd">.. code-block:: sh</span>

<span class="sd">    &gt; psql9 &lt;database&gt; -c&quot;select unaccent(&#39;hélène&#39;)&quot;</span>

<span class="sd">Finally, to instruct OpenERP to really use the unaccent function, you have to</span>
<span class="sd">start the server specifying the ``--unaccent`` flag.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">reprlib</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">time</span>

<span class="kn">import</span> <span class="nn">psycopg2.sql</span>

<span class="kn">import</span> <span class="nn">odoo.modules</span>
<span class="kn">from</span> <span class="nn">odoo.models</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">check_property_field_value_name</span>
<span class="kn">from</span> <span class="nn">odoo.tools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">pycompat</span><span class="p">,</span> <span class="n">pattern_to_translated_trigram_pattern</span><span class="p">,</span> <span class="n">value_to_translated_trigram_pattern</span><span class="p">,</span>
    <span class="n">Query</span><span class="p">,</span> <span class="n">SQL</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1"># Domain operators.</span>
<span class="n">NOT_OPERATOR</span> <span class="o">=</span> <span class="s1">&#39;!&#39;</span>
<span class="n">OR_OPERATOR</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span>
<span class="n">AND_OPERATOR</span> <span class="o">=</span> <span class="s1">&#39;&amp;&#39;</span>
<span class="n">DOMAIN_OPERATORS</span> <span class="o">=</span> <span class="p">(</span><span class="n">NOT_OPERATOR</span><span class="p">,</span> <span class="n">OR_OPERATOR</span><span class="p">,</span> <span class="n">AND_OPERATOR</span><span class="p">)</span>

<span class="c1"># List of available term operators. It is also possible to use the &#39;&lt;&gt;&#39;</span>
<span class="c1"># operator, which is strictly the same as &#39;!=&#39;; the later should be preferred</span>
<span class="c1"># for consistency. This list doesn&#39;t contain &#39;&lt;&gt;&#39; as it is simplified to &#39;!=&#39;</span>
<span class="c1"># by the normalize_operator() function (so later part of the code deals with</span>
<span class="c1"># only one representation).</span>
<span class="c1"># Internals (i.e. not available to the user) &#39;inselect&#39; and &#39;not inselect&#39;</span>
<span class="c1"># operators are also used. In this case its right operand has the form (subselect, params).</span>
<span class="n">TERM_OPERATORS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;=?&#39;</span><span class="p">,</span> <span class="s1">&#39;=like&#39;</span><span class="p">,</span> <span class="s1">&#39;=ilike&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;like&#39;</span><span class="p">,</span> <span class="s1">&#39;not like&#39;</span><span class="p">,</span> <span class="s1">&#39;ilike&#39;</span><span class="p">,</span> <span class="s1">&#39;not ilike&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;not in&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;child_of&#39;</span><span class="p">,</span> <span class="s1">&#39;parent_of&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">)</span>

<span class="c1"># A subset of the above operators, with a &#39;negative&#39; semantic. When the</span>
<span class="c1"># expressions &#39;in NEGATIVE_TERM_OPERATORS&#39; or &#39;not in NEGATIVE_TERM_OPERATORS&#39; are used in the code</span>
<span class="c1"># below, this doesn&#39;t necessarily mean that any of those NEGATIVE_TERM_OPERATORS is</span>
<span class="c1"># legal in the processed term.</span>
<span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="s1">&#39;not like&#39;</span><span class="p">,</span> <span class="s1">&#39;not ilike&#39;</span><span class="p">,</span> <span class="s1">&#39;not in&#39;</span><span class="p">)</span>

<span class="c1"># Negation of domain expressions</span>
<span class="n">DOMAIN_OPERATORS_NEGATION</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">AND_OPERATOR</span><span class="p">:</span> <span class="n">OR_OPERATOR</span><span class="p">,</span>
    <span class="n">OR_OPERATOR</span><span class="p">:</span> <span class="n">AND_OPERATOR</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">TERM_OPERATORS_NEGATION</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">,</span>
    <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span>
    <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
    <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span>
    <span class="s1">&#39;=&#39;</span><span class="p">:</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span>
    <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span>
    <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="s1">&#39;not in&#39;</span><span class="p">,</span>
    <span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="s1">&#39;not like&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ilike&#39;</span><span class="p">:</span> <span class="s1">&#39;not ilike&#39;</span><span class="p">,</span>
    <span class="s1">&#39;not in&#39;</span><span class="p">:</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span>
    <span class="s1">&#39;not like&#39;</span><span class="p">:</span> <span class="s1">&#39;like&#39;</span><span class="p">,</span>
    <span class="s1">&#39;not ilike&#39;</span><span class="p">:</span> <span class="s1">&#39;ilike&#39;</span><span class="p">,</span>
    <span class="s1">&#39;any&#39;</span><span class="p">:</span> <span class="s1">&#39;not any&#39;</span><span class="p">,</span>
    <span class="s1">&#39;not any&#39;</span><span class="p">:</span> <span class="s1">&#39;any&#39;</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">ANY_IN</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;any&#39;</span><span class="p">:</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">:</span> <span class="s1">&#39;not in&#39;</span><span class="p">}</span>

<span class="n">TRUE_LEAF</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">FALSE_LEAF</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">TRUE_DOMAIN</span> <span class="o">=</span> <span class="p">[</span><span class="n">TRUE_LEAF</span><span class="p">]</span>
<span class="n">FALSE_DOMAIN</span> <span class="o">=</span> <span class="p">[</span><span class="n">FALSE_LEAF</span><span class="p">]</span>

<span class="n">SQL_OPERATORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;=&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">),</span>
    <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">),</span>
    <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;&lt;=&#39;</span><span class="p">),</span>
    <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">),</span>
    <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">),</span>
    <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;&gt;=&#39;</span><span class="p">),</span>
    <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;IN&#39;</span><span class="p">),</span>
    <span class="s1">&#39;not in&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;NOT IN&#39;</span><span class="p">),</span>
    <span class="s1">&#39;=like&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;LIKE&#39;</span><span class="p">),</span>
    <span class="s1">&#39;=ilike&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;ILIKE&#39;</span><span class="p">),</span>
    <span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;LIKE&#39;</span><span class="p">),</span>
    <span class="s1">&#39;ilike&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;ILIKE&#39;</span><span class="p">),</span>
    <span class="s1">&#39;not like&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;NOT LIKE&#39;</span><span class="p">),</span>
    <span class="s1">&#39;not ilike&#39;</span><span class="p">:</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;NOT ILIKE&#39;</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># --------------------------------------------------</span>
<span class="c1"># Generic domain manipulation</span>
<span class="c1"># --------------------------------------------------</span>

<div class="viewcode-block" id="normalize_domain">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.normalize_domain">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a normalized version of ``domain_expr``, where all implicit &#39;&amp;&#39; operators</span>
<span class="sd">       have been made explicit. One property of normalized domain expressions is that they</span>
<span class="sd">       can be easily combined together as if they were single domain components.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)),</span> <span class="s2">&quot;Domains to normalize must have a &#39;domain&#39; form: a list or tuple of domain components&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">domain</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">TRUE_LEAF</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span>                            <span class="c1"># expected number of expressions</span>
    <span class="n">op_arity</span> <span class="o">=</span> <span class="p">{</span><span class="n">NOT_OPERATOR</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">AND_OPERATOR</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">OR_OPERATOR</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">expected</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                   <span class="c1"># more than expected, like in [A, B]</span>
            <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">AND_OPERATOR</span><span class="p">]</span>             <span class="c1"># put an extra &#39;&amp;&#39; in front</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>  <span class="c1"># domain term</span>
            <span class="n">expected</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">):</span>
                <span class="n">token</span> <span class="o">=</span> <span class="p">(</span><span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">normalize_domain</span><span class="p">(</span><span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">token</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expected</span> <span class="o">+=</span> <span class="n">op_arity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expected</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Domain </span><span class="si">{</span><span class="n">domain</span><span class="si">}</span><span class="s1"> is syntactically not correct.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="is_false">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.is_false">[docs]</a>
<span class="k">def</span> <span class="nf">is_false</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return whether ``domain`` is logically equivalent to false. &quot;&quot;&quot;</span>
    <span class="c1"># use three-valued logic: -1 is false, 0 is unknown, +1 is true</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">normalize_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="n">TRUE_LEAF</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="n">FALSE_LEAF</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Query</span><span class="p">)</span> <span class="ow">or</span> <span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;not in&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Query</span><span class="p">)</span> <span class="ow">or</span> <span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span></div>



<div class="viewcode-block" id="combine">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.combine">[docs]</a>
<span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">domains</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a new domain expression where all domain components from ``domains``</span>
<span class="sd">       have been added together using the binary operator ``operator``.</span>

<span class="sd">       It is guaranteed to return a normalized domain.</span>

<span class="sd">       :param operator:</span>
<span class="sd">       :param unit: the identity element of the domains &quot;set&quot; with regard to the operation</span>
<span class="sd">                    performed by ``operator``, i.e the domain component ``i`` which, when</span>
<span class="sd">                    combined with any domain ``x`` via ``operator``, yields ``x``.</span>
<span class="sd">                    E.g. [(1,&#39;=&#39;,1)] is the typical unit for AND_OPERATOR: adding it</span>
<span class="sd">                    to any domain component gives the same domain.</span>
<span class="sd">       :param zero: the absorbing element of the domains &quot;set&quot; with regard to the operation</span>
<span class="sd">                    performed by ``operator``, i.e the domain component ``z`` which, when</span>
<span class="sd">                    combined with any domain ``x`` via ``operator``, yields ``z``.</span>
<span class="sd">                    E.g. [(1,&#39;=&#39;,1)] is the typical zero for OR_OPERATOR: as soon as</span>
<span class="sd">                    you see it in a domain component the resulting domain is the zero.</span>
<span class="sd">       :param domains: a list of normalized domains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">domains</span> <span class="o">==</span> <span class="p">[</span><span class="n">unit</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">unit</span>
    <span class="k">for</span> <span class="n">domain</span> <span class="ow">in</span> <span class="n">domains</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="n">unit</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">if</span> <span class="n">domain</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">normalize_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">operator</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">result</span> <span class="ow">or</span> <span class="n">unit</span></div>



<div class="viewcode-block" id="AND">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.AND">[docs]</a>
<span class="k">def</span> <span class="nf">AND</span><span class="p">(</span><span class="n">domains</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;AND([D1,D2,...]) returns a domain representing D1 and D2 and ... &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">combine</span><span class="p">(</span><span class="n">AND_OPERATOR</span><span class="p">,</span> <span class="p">[</span><span class="n">TRUE_LEAF</span><span class="p">],</span> <span class="p">[</span><span class="n">FALSE_LEAF</span><span class="p">],</span> <span class="n">domains</span><span class="p">)</span></div>



<div class="viewcode-block" id="OR">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.OR">[docs]</a>
<span class="k">def</span> <span class="nf">OR</span><span class="p">(</span><span class="n">domains</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;OR([D1,D2,...]) returns a domain representing D1 or D2 or ... &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">combine</span><span class="p">(</span><span class="n">OR_OPERATOR</span><span class="p">,</span> <span class="p">[</span><span class="n">FALSE_LEAF</span><span class="p">],</span> <span class="p">[</span><span class="n">TRUE_LEAF</span><span class="p">],</span> <span class="n">domains</span><span class="p">)</span></div>



<div class="viewcode-block" id="distribute_not">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.distribute_not">[docs]</a>
<span class="k">def</span> <span class="nf">distribute_not</span><span class="p">(</span><span class="n">domain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Distribute any &#39;!&#39; domain operators found inside a normalized domain.</span>

<span class="sd">    Because we don&#39;t use SQL semantic for processing a &#39;left not in right&#39;</span>
<span class="sd">    query (i.e. our &#39;not in&#39; is not simply translated to a SQL &#39;not in&#39;),</span>
<span class="sd">    it means that a &#39;! left in right&#39; can not be simply processed</span>
<span class="sd">    by __leaf_to_sql by first emitting code for &#39;left in right&#39; then wrapping</span>
<span class="sd">    the result with &#39;not (...)&#39;, as it would result in a &#39;not in&#39; at the SQL</span>
<span class="sd">    level.</span>

<span class="sd">    This function is thus responsible for pushing any &#39;!&#39; domain operators</span>
<span class="sd">    inside the terms themselves. For example::</span>

<span class="sd">         [&#39;!&#39;,&#39;&amp;&#39;,(&#39;user_id&#39;,&#39;=&#39;,4),(&#39;partner_id&#39;,&#39;in&#39;,[1,2])]</span>
<span class="sd">            will be turned into:</span>
<span class="sd">         [&#39;|&#39;,(&#39;user_id&#39;,&#39;!=&#39;,4),(&#39;partner_id&#39;,&#39;not in&#39;,[1,2])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This is an iterative version of a recursive function that split domain</span>
    <span class="c1"># into subdomains, processes them and combine the results. The &quot;stack&quot; below</span>
    <span class="c1"># represents the recursive calls to be done.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">:</span>
        <span class="n">negate</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># negate tells whether the subdomain starting with token must be negated</span>
        <span class="k">if</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">negate</span><span class="p">:</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">token</span>
                <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">TERM_OPERATORS_NEGATION</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="p">(</span><span class="n">TRUE_LEAF</span><span class="p">,</span> <span class="n">FALSE_LEAF</span><span class="p">):</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FALSE_LEAF</span> <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="n">TRUE_LEAF</span> <span class="k">else</span> <span class="n">TRUE_LEAF</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">TERM_OPERATORS_NEGATION</span><span class="p">[</span><span class="n">operator</span><span class="p">],</span> <span class="n">right</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NOT_OPERATOR</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="n">NOT_OPERATOR</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="ow">not</span> <span class="n">negate</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">DOMAIN_OPERATORS_NEGATION</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DOMAIN_OPERATORS_NEGATION</span><span class="p">[</span><span class="n">token</span><span class="p">]</span> <span class="k">if</span> <span class="n">negate</span> <span class="k">else</span> <span class="n">token</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">negate</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">negate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<span class="k">def</span> <span class="nf">_anyfy_leaves</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the domain where all conditions on field sequences have been</span>
<span class="sd">    transformed into &#39;any&#39; conditions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_operator</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">item</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_boolean</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">field</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid field </span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> in leaf </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">relational</span><span class="p">:</span>  <span class="c1"># skip properties</span>
            <span class="n">subdomain</span> <span class="o">=</span> <span class="p">[(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)]</span>
            <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">_anyfy_leaves</span><span class="p">(</span><span class="n">subdomain</span><span class="p">,</span> <span class="n">comodel</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">):</span>
            <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">_anyfy_leaves</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">comodel</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_tree_from_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the domain as a tree, with the following structure::</span>

<span class="sd">        &lt;tree&gt; ::= (&#39;?&#39;, &lt;boolean&gt;)</span>
<span class="sd">                |  (&#39;!&#39;, &lt;tree&gt;)</span>
<span class="sd">                |  (&#39;&amp;&#39;, &lt;tree&gt;, &lt;tree&gt;, ...)</span>
<span class="sd">                |  (&#39;|&#39;, &lt;tree&gt;, &lt;tree&gt;, ...)</span>
<span class="sd">                |  (&lt;comparator&gt;, &lt;fname&gt;, &lt;value&gt;)</span>

<span class="sd">    By construction, AND (``&amp;``) and OR (``|``) nodes are n-ary and have at</span>
<span class="sd">    least two children.  Moreover, AND nodes (respectively OR nodes) do not have</span>
<span class="sd">    AND nodes (resp. OR nodes) in their children.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">domain</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tree_not</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tree_and</span><span class="p">((</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())))</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_tree_or</span><span class="p">((</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())))</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="n">TRUE_LEAF</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="n">FALSE_LEAF</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lhs</span><span class="p">,</span> <span class="n">comparator</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">if</span> <span class="n">comparator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">):</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">_tree_from_domain</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">comparator</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_tree_and</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">stack</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_tree_not</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Negate a tree node. &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;?&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="ow">not</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">_tree_not</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">_tree_not</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">TERM_OPERATORS_NEGATION</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">TERM_OPERATORS_NEGATION</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tree_and</span><span class="p">(</span><span class="n">trees</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the tree given by AND-ing all the given trees. &quot;&quot;&quot;</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tree</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">tree</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tree</span>
        <span class="k">elif</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">children</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tree_or</span><span class="p">(</span><span class="n">trees</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the tree given by OR-ing all the given trees. &quot;&quot;&quot;</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tree</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tree</span>
        <span class="k">elif</span> <span class="n">tree</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">children</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tree_combine_anies</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the tree given by recursively merging &#39;any&#39; and &#39;not any&#39; nodes,</span>
<span class="sd">    according to the following logical equivalences:</span>

<span class="sd">     * (fname ANY dom1) OR (fname ANY dom2) == (fname ANY (dom1 OR dom2))</span>

<span class="sd">     * (fname NOT ANY dom1) AND (fname NOT ANY dom2) == (fname NOT ANY (dom1 OR dom2))</span>

<span class="sd">    We also merge &#39;any&#39; and &#39;not any&#39; nodes according to the following logical</span>
<span class="sd">    equivalences *for many2one fields only*:</span>

<span class="sd">     * (fname NOT ANY dom1) OR (fname NOT ANY dom2) == (fname NOT ANY (dom1 AND dom2))</span>

<span class="sd">     * (fname ANY dom1) AND (fname ANY dom2) == (fname ANY (dom1 AND dom2))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># first proceed recursively on subtrees</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">_tree_not</span><span class="p">(</span><span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">model</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span> <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">_tree_and</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span> <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">_tree_or</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

    <span class="c1"># proceed recursively on subdomains</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;any&#39;</span><span class="p">:</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">comodel</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;not any&#39;</span><span class="p">:</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;not any&#39;</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">comodel</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;|&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tree</span>

    <span class="c1"># tree is either an &#39;&amp;&#39; or an &#39;|&#39; tree; group leaves using &#39;any&#39; or &#39;not any&#39;</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">any_children</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">not_any_children</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">subtree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;any&#39;</span><span class="p">:</span>
            <span class="n">any_children</span><span class="p">[</span><span class="n">subtree</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">subtree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;not any&#39;</span><span class="p">:</span>
            <span class="n">not_any_children</span><span class="p">[</span><span class="n">subtree</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
        <span class="c1"># merge subdomains where possible</span>
        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">subtrees</span> <span class="ow">in</span> <span class="n">any_children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
            <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;many2one&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subtrees</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># (fname ANY dom1) AND (fname ANY dom2) == (fname ANY (dom1 AND dom2))</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">_tree_and</span><span class="p">(</span><span class="n">subtrees</span><span class="p">),</span> <span class="n">comodel</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">subtrees</span><span class="p">:</span>
                    <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">comodel</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">subtrees</span> <span class="ow">in</span> <span class="n">not_any_children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># (fname NOT ANY dom1) AND (fname NOT ANY dom2) == (fname NOT ANY (dom1 OR dom2))</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
            <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">]</span>
            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;not any&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">_tree_or</span><span class="p">(</span><span class="n">subtrees</span><span class="p">),</span> <span class="n">comodel</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">_tree_and</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># merge subdomains where possible</span>
        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">subtrees</span> <span class="ow">in</span> <span class="n">any_children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># (fname ANY dom1) OR (fname ANY dom2) == (fname ANY (dom1 OR dom2))</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
            <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">]</span>
            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">_tree_or</span><span class="p">(</span><span class="n">subtrees</span><span class="p">),</span> <span class="n">comodel</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">subtrees</span> <span class="ow">in</span> <span class="n">not_any_children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
            <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;many2one&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subtrees</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># (fname NOT ANY dom1) OR (fname NOT ANY dom2) == (fname NOT ANY (dom1 AND dom2))</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;not any&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">_tree_and</span><span class="p">(</span><span class="n">subtrees</span><span class="p">),</span> <span class="n">comodel</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">subtrees</span><span class="p">:</span>
                    <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;not any&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">comodel</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">_tree_or</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tree_as_domain</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the domain list represented by the given domain tree. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;?&#39;</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">TRUE_LEAF</span> <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">FALSE_LEAF</span>
        <span class="k">elif</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">yield from</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;|&#39;</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">yield from</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_tree_as_domain</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">_flatten</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>


<div class="viewcode-block" id="domain_combine_anies">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.domain_combine_anies">[docs]</a>
<span class="k">def</span> <span class="nf">domain_combine_anies</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return a domain equivalent to the given one where &#39;any&#39; and &#39;not any&#39;</span>
<span class="sd">    conditions have been combined in order to generate less subqueries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">domain_any</span> <span class="o">=</span> <span class="n">_anyfy_leaves</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">_tree_from_domain</span><span class="p">(</span><span class="n">domain_any</span><span class="p">)</span>
    <span class="n">merged_tree</span> <span class="o">=</span> <span class="n">_tree_combine_anies</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
    <span class="n">new_domain</span> <span class="o">=</span> <span class="n">_tree_as_domain</span><span class="p">(</span><span class="n">merged_tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_domain</span></div>



<div class="viewcode-block" id="prettify_domain">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.prettify_domain">[docs]</a>
<span class="k">def</span> <span class="nf">prettify_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">pre_indent</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pretty-format a domain into a string by separating each leaf on a</span>
<span class="sd">    separated line and by including some indentation. Works with ``any``</span>
<span class="sd">    and ``not any`` too. The domain must be normalized.</span>

<span class="sd">    :param list domain: a normalized domain</span>
<span class="sd">    :param int pre_indent: (optinal) a starting indentation level</span>
<span class="sd">    :return: the domain prettified</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># The ``stack`` is a stack of layers, each layer accumulates the</span>
    <span class="c1"># ``terms`` (leaves/operators) that share a same indentation</span>
    <span class="c1"># level (the depth of the layer inside the stack). ``left_count``</span>
    <span class="c1"># tracks how many terms should still appear on each layer before the</span>
    <span class="c1"># layer is considered complete.</span>
    <span class="c1">#</span>
    <span class="c1"># When a layer is completed, it is removed from the stack and</span>
    <span class="c1"># commited, i.e. its terms added to the ``commits`` list along with</span>
    <span class="c1"># the indentation for those terms.</span>
    <span class="c1">#</span>
    <span class="c1"># When a new operator is added to the layer terms, the current layer</span>
    <span class="c1"># is commited (but not removed from the stack if there are still</span>
    <span class="c1"># some terms that must be added) and a new (empty) layer is added on</span>
    <span class="c1"># top of the stack.</span>
    <span class="c1">#</span>
    <span class="c1"># When the domain has been fully iterated, the commits are used to</span>
    <span class="c1"># craft the final string. All terms are indented according to their</span>
    <span class="c1"># commit indentation level and separated by a new line.</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;left_count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;terms&#39;</span><span class="p">:</span> <span class="p">[]}]</span>
    <span class="n">commits</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">:</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_operator</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
            <span class="c1"># when a same operator appears twice in a row, we want to</span>
            <span class="c1"># include the second one on the same line as the former one</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">top</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">commits</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">commits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">term</span><span class="p">))):</span>
                <span class="n">commits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;terms&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;, </span><span class="si">{</span><span class="n">term</span><span class="si">!r}</span><span class="s2">&quot;</span>  <span class="c1"># hack</span>
                <span class="n">top</span><span class="p">[</span><span class="s1">&#39;left_count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">term</span> <span class="o">==</span> <span class="n">NOT_OPERATOR</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">commits</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;indent&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;terms&#39;</span><span class="p">:</span> <span class="n">top</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">term</span><span class="p">)]</span>
                <span class="p">})</span>
                <span class="n">top</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">top</span><span class="p">[</span><span class="s1">&#39;left_count&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;left_count&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">term</span> <span class="o">==</span> <span class="n">NOT_OPERATOR</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="s1">&#39;terms&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="p">})</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">):</span>
            <span class="n">top</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">term</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">prettify_domain</span><span class="p">(</span><span class="n">term</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pre_indent</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">top</span><span class="p">[</span><span class="s1">&#39;left_count&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">top</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">term</span><span class="p">))</span>
            <span class="n">top</span><span class="p">[</span><span class="s1">&#39;left_count&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">top</span><span class="p">[</span><span class="s1">&#39;left_count&#39;</span><span class="p">]:</span>
            <span class="n">commits</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;indent&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;terms&#39;</span><span class="p">:</span> <span class="n">top</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span>
            <span class="p">})</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">return</span> <span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;,</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;    &#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pre_indent</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;    &#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">commit</span><span class="p">[</span><span class="s1">&#39;indent&#39;</span><span class="p">]</span><span class="si">}{</span><span class="n">term</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">commit</span> <span class="ow">in</span> <span class="n">commits</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">commit</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span>
        <span class="p">])</span>
    <span class="p">)</span></div>



<span class="c1"># --------------------------------------------------</span>
<span class="c1"># Generic leaf manipulation</span>
<span class="c1"># --------------------------------------------------</span>

<div class="viewcode-block" id="normalize_leaf">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.normalize_leaf">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_leaf</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Change a term&#39;s operator to some canonical form, simplifying later</span>
<span class="sd">        processing. &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">element</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">operator</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">:</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="s1">&#39;!=&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;not in&#39;</span><span class="p">):</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The domain term &#39;</span><span class="si">%s</span><span class="s2">&#39; should use the &#39;=&#39; or &#39;!=&#39; operator.&quot;</span> <span class="o">%</span> <span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">right</span><span class="p">),))</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="s1">&#39;=&#39;</span> <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span> <span class="k">else</span> <span class="s1">&#39;!=&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">):</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The domain term &#39;</span><span class="si">%s</span><span class="s2">&#39; should use the &#39;in&#39; or &#39;not in&#39; operator.&quot;</span> <span class="o">%</span> <span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">right</span><span class="p">),))</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="s1">&#39;in&#39;</span> <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span> <span class="k">else</span> <span class="s1">&#39;not in&#39;</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span></div>



<div class="viewcode-block" id="is_operator">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.is_operator">[docs]</a>
<span class="k">def</span> <span class="nf">is_operator</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Test whether an object is a valid domain operator. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">DOMAIN_OPERATORS</span></div>



<div class="viewcode-block" id="is_leaf">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.is_leaf">[docs]</a>
<span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Test whether an object is a valid domain term:</span>

<span class="sd">        - is a list or tuple</span>
<span class="sd">        - with 3 elements</span>
<span class="sd">        - second element if a valid op</span>

<span class="sd">        :param tuple element: a leaf in form (left, operator, right)</span>
<span class="sd">        :param bool internal: allow or not the &#39;inselect&#39; internal operator</span>
<span class="sd">            in the term. This should be always left to False.</span>

<span class="sd">        Note: OLD TODO change the share wizard to use this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">INTERNAL_OPS</span> <span class="o">=</span> <span class="n">TERM_OPERATORS</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">internal</span><span class="p">:</span>
        <span class="n">INTERNAL_OPS</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;inselect&#39;</span><span class="p">,</span> <span class="s1">&#39;not inselect&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> \
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> \
        <span class="ow">and</span> <span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">INTERNAL_OPS</span> \
        <span class="ow">and</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
             <span class="ow">or</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">TRUE_LEAF</span><span class="p">,</span> <span class="n">FALSE_LEAF</span><span class="p">))</span></div>



<div class="viewcode-block" id="is_boolean">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.is_boolean">[docs]</a>
<span class="k">def</span> <span class="nf">is_boolean</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">element</span> <span class="o">==</span> <span class="n">TRUE_LEAF</span> <span class="ow">or</span> <span class="n">element</span> <span class="o">==</span> <span class="n">FALSE_LEAF</span></div>



<div class="viewcode-block" id="check_leaf">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.check_leaf">[docs]</a>
<span class="k">def</span> <span class="nf">check_leaf</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_operator</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">internal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid leaf </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">))</span></div>



<span class="c1"># --------------------------------------------------</span>
<span class="c1"># SQL utils</span>
<span class="c1"># --------------------------------------------------</span>

<span class="k">def</span> <span class="nf">_unaccent_wrapper</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">SQL</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;unaccent(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">Composable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;unaccent(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;unaccent(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="get_unaccent_wrapper">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.get_unaccent_wrapper">[docs]</a>
<span class="k">def</span> <span class="nf">get_unaccent_wrapper</span><span class="p">(</span><span class="n">cr</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">odoo</span><span class="o">.</span><span class="n">registry</span><span class="p">(</span><span class="n">cr</span><span class="o">.</span><span class="n">dbname</span><span class="p">)</span><span class="o">.</span><span class="n">has_unaccent</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unaccent_wrapper</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span></div>



<div class="viewcode-block" id="expression">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.expression">[docs]</a>
<span class="k">class</span> <span class="nc">expression</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Parse a domain expression</span>
<span class="sd">        Use a real polish notation</span>
<span class="sd">        Leafs are still in a (&#39;foo&#39;, &#39;=&#39;, &#39;bar&#39;) format</span>
<span class="sd">        For more info: http://christophe-simonis-at-tiny.blogspot.com/2008/08/new-new-domain-notation.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initialize expression object and automatically parse the expression</span>
<span class="sd">            right after initialization.</span>

<span class="sd">            :param domain: expression (using domain (&#39;foo&#39;, &#39;=&#39;, &#39;bar&#39;) format)</span>
<span class="sd">            :param model: root model</span>
<span class="sd">            :param alias: alias for the model table if query is provided</span>
<span class="sd">            :param query: optional query object holding the final result</span>

<span class="sd">            :attr root_model: base model for the query</span>
<span class="sd">            :attr expression: the domain to parse, normalized and prepared</span>
<span class="sd">            :attr result: the result of the parsing, as a pair (query, params)</span>
<span class="sd">            :attr query: Query object holding the final result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unaccent_wrapper</span> <span class="o">=</span> <span class="n">get_unaccent_wrapper</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">_cr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_trigram</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">has_trigram</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_alias</span> <span class="o">=</span> <span class="n">alias</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">_table</span>

        <span class="c1"># normalize and prepare the expression for parsing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">domain_combine_anies</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

        <span class="c1"># this object handles all the joins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">Query</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cr</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">_table</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">_table_query</span><span class="p">)</span> <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">query</span>

        <span class="c1"># parse the domain expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_unaccent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;unaccent&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unaccent_wrapper</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

    <span class="c1"># ----------------------------------------</span>
    <span class="c1"># Parsing</span>
    <span class="c1"># ----------------------------------------</span>

<div class="viewcode-block" id="expression.parse">
<a class="viewcode-back" href="../../../odoo.osv.html#odoo.osv.expression.expression.parse">[docs]</a>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Transform the leaves of the expression</span>

<span class="sd">        The principle is to pop elements from a leaf stack one at a time.</span>
<span class="sd">        Each leaf is processed. The processing is a if/elif list of various</span>
<span class="sd">        cases that appear in the leafs (many2one, function fields, ...).</span>

<span class="sd">        Three things can happen as a processing result:</span>

<span class="sd">        - the leaf is a logic operator, and updates the result stack</span>
<span class="sd">          accordingly;</span>
<span class="sd">        - the leaf has been modified and/or new leafs have to be introduced</span>
<span class="sd">          in the expression; they are pushed into the leaf stack, to be</span>
<span class="sd">          processed right after;</span>
<span class="sd">        - the leaf is converted to SQL and added to the result stack</span>

<span class="sd">        Example:</span>

<span class="sd">        =================== =================== =====================</span>
<span class="sd">        step                stack               result_stack</span>
<span class="sd">        =================== =================== =====================</span>
<span class="sd">                            [&#39;&amp;&#39;, A, B]         []</span>
<span class="sd">        substitute B        [&#39;&amp;&#39;, A, B1]        []</span>
<span class="sd">        convert B1 in SQL   [&#39;&amp;&#39;, A]            [&quot;B1&quot;]</span>
<span class="sd">        substitute A        [&#39;&amp;&#39;, &#39;|&#39;, A1, A2]  [&quot;B1&quot;]</span>
<span class="sd">        convert A2 in SQL   [&#39;&amp;&#39;, &#39;|&#39;, A1]      [&quot;B1&quot;, &quot;A2&quot;]</span>
<span class="sd">        convert A1 in SQL   [&#39;&amp;&#39;, &#39;|&#39;]          [&quot;B1&quot;, &quot;A2&quot;, &quot;A1&quot;]</span>
<span class="sd">        apply operator OR   [&#39;&amp;&#39;]               [&quot;B1&quot;, &quot;A1 or A2&quot;]</span>
<span class="sd">        apply operator AND  []                  [&quot;(A1 or A2) and B1&quot;]</span>
<span class="sd">        =================== =================== =====================</span>

<span class="sd">        Some internal var explanation:</span>

<span class="sd">        :var list path: left operand seen as a sequence of field names</span>
<span class="sd">            (&quot;foo.bar&quot; -&gt; [&quot;foo&quot;, &quot;bar&quot;])</span>
<span class="sd">        :var obj model: model object, model containing the field</span>
<span class="sd">            (the name provided in the left operand)</span>
<span class="sd">        :var obj field: the field corresponding to `path[0]`</span>
<span class="sd">        :var obj column: the column corresponding to `path[0]`</span>
<span class="sd">        :var obj comodel: relational model of field (field.comodel)</span>
<span class="sd">            (res_partner.bank_ids -&gt; res.partner.bank)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">to_ids</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">comodel</span><span class="p">,</span> <span class="n">leaf</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Normalize a single id or name, or a list of those, into a list of ids</span>

<span class="sd">            :param comodel:</span>
<span class="sd">            :param leaf:</span>
<span class="sd">            :param int|str|list|tuple value:</span>

<span class="sd">                - if int, long -&gt; return [value]</span>
<span class="sd">                - if basestring, convert it into a list of basestrings, then</span>
<span class="sd">                - if list of basestring -&gt;</span>

<span class="sd">                    - perform a name_search on comodel for each name</span>
<span class="sd">                    - return the list of related ids</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">value</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
                    <span class="c1"># given this nonsensical domain, it is generally cheaper to</span>
                    <span class="c1"># interpret False as [], so that &quot;X child_of False&quot; will</span>
                    <span class="c1"># match nothing</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unexpected domain [</span><span class="si">%s</span><span class="s2">], interpreted as False&quot;</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">({</span>
                    <span class="n">rid</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span>
                    <span class="k">for</span> <span class="n">rid</span> <span class="ow">in</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_name_search</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[],</span> <span class="s1">&#39;ilike&#39;</span><span class="p">)</span>
                <span class="p">})</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">child_of_domain</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">left_model</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Return a domain implementing the child_of operator for [(left,child_of,ids)],</span>
<span class="sd">                either as a range using the parent_path tree lookup field</span>
<span class="sd">                (when available), or as an expanded [(left,in,child_ids)] &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ids</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">FALSE_LEAF</span><span class="p">]</span>
            <span class="n">left_model_sudo</span> <span class="o">=</span> <span class="n">left_model</span><span class="o">.</span><span class="n">sudo</span><span class="p">()</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">active_test</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left_model</span><span class="o">.</span><span class="n">_parent_store</span><span class="p">:</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">OR</span><span class="p">([</span>
                    <span class="p">[(</span><span class="s1">&#39;parent_path&#39;</span><span class="p">,</span> <span class="s1">&#39;=like&#39;</span><span class="p">,</span> <span class="n">rec</span><span class="o">.</span><span class="n">parent_path</span> <span class="o">+</span> <span class="s1">&#39;%&#39;</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">left_model_sudo</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
                <span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># recursively retrieve all children nodes with sudo(); the</span>
                <span class="c1"># filtering of forbidden records is done by the rest of the</span>
                <span class="c1"># domain</span>
                <span class="n">parent_name</span> <span class="o">=</span> <span class="n">parent</span> <span class="ow">or</span> <span class="n">left_model</span><span class="o">.</span><span class="n">_parent_name</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">left_model</span><span class="o">.</span><span class="n">_name</span> <span class="o">!=</span> <span class="n">left_model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid parent field: </span><span class="si">{</span><span class="n">left_model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">child_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">records</span> <span class="o">=</span> <span class="n">left_model_sudo</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">records</span><span class="p">:</span>
                    <span class="n">child_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">records</span><span class="o">.</span><span class="n">_ids</span><span class="p">)</span>
                    <span class="n">records</span> <span class="o">=</span> <span class="n">records</span><span class="o">.</span><span class="n">search</span><span class="p">([(</span><span class="n">parent_name</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">records</span><span class="o">.</span><span class="n">ids</span><span class="p">)],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">records</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">child_ids</span><span class="p">)</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">child_ids</span><span class="p">))]</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">left_model_sudo</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">domain</span><span class="p">))]</span>
            <span class="k">return</span> <span class="n">domain</span>

        <span class="k">def</span> <span class="nf">parent_of_domain</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">left_model</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Return a domain implementing the parent_of operator for [(left,parent_of,ids)],</span>
<span class="sd">                either as a range using the parent_path tree lookup field</span>
<span class="sd">                (when available), or as an expanded [(left,in,parent_ids)] &quot;&quot;&quot;</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">id</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span> <span class="k">if</span> <span class="nb">id</span><span class="p">]</span>  <span class="c1"># ignore (left, &#39;parent_of&#39;, [False])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ids</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">FALSE_LEAF</span><span class="p">]</span>
            <span class="n">left_model_sudo</span> <span class="o">=</span> <span class="n">left_model</span><span class="o">.</span><span class="n">sudo</span><span class="p">()</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">active_test</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left_model</span><span class="o">.</span><span class="n">_parent_store</span><span class="p">:</span>
                <span class="n">parent_ids</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">left_model_sudo</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">rec</span><span class="o">.</span><span class="n">parent_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">parent_ids</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># recursively retrieve all parent nodes with sudo() to avoid</span>
                <span class="c1"># access rights errors; the filtering of forbidden records is</span>
                <span class="c1"># done by the rest of the domain</span>
                <span class="n">parent_name</span> <span class="o">=</span> <span class="n">parent</span> <span class="ow">or</span> <span class="n">left_model</span><span class="o">.</span><span class="n">_parent_name</span>
                <span class="n">parent_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">records</span> <span class="o">=</span> <span class="n">left_model_sudo</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">records</span><span class="p">:</span>
                    <span class="n">parent_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">records</span><span class="o">.</span><span class="n">_ids</span><span class="p">)</span>
                    <span class="n">records</span> <span class="o">=</span> <span class="n">records</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span> <span class="o">-</span> <span class="n">records</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">parent_ids</span><span class="p">)</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">parent_ids</span><span class="p">))]</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">left_model_sudo</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">domain</span><span class="p">))]</span>
            <span class="k">return</span> <span class="n">domain</span>

        <span class="n">HIERARCHY_FUNCS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;child_of&#39;</span><span class="p">:</span> <span class="n">child_of_domain</span><span class="p">,</span>
                           <span class="s1">&#39;parent_of&#39;</span><span class="p">:</span> <span class="n">parent_of_domain</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">pop</span><span class="p">():</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Pop a leaf to process. &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Push a leaf to be processed right after. &quot;&quot;&quot;</span>
            <span class="n">leaf</span> <span class="o">=</span> <span class="n">normalize_leaf</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
            <span class="n">check_leaf</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">internal</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">pop_result</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">result_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">push_result</span><span class="p">(</span><span class="n">sql</span><span class="p">):</span>
            <span class="n">result_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>

        <span class="c1"># process domain from right to left; stack contains domain leaves, in</span>
        <span class="c1"># the form: (leaf, corresponding model, corresponding table alias)</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">:</span>
            <span class="n">push</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_alias</span><span class="p">)</span>

        <span class="c1"># stack of SQL expressions</span>
        <span class="n">result_stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="c1"># Get the next leaf to process</span>
            <span class="n">leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span> <span class="o">=</span> <span class="n">pop</span><span class="p">()</span>

            <span class="c1"># ----------------------------------------</span>
            <span class="c1"># SIMPLE CASE</span>
            <span class="c1"># 1. leaf is an operator</span>
            <span class="c1"># 2. leaf is a true/false leaf</span>
            <span class="c1"># -&gt; convert and add directly to result</span>
            <span class="c1"># ----------------------------------------</span>

            <span class="k">if</span> <span class="n">is_operator</span><span class="p">(</span><span class="n">leaf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">leaf</span> <span class="o">==</span> <span class="n">NOT_OPERATOR</span><span class="p">:</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(NOT (</span><span class="si">%s</span><span class="s2">))&quot;</span><span class="p">,</span> <span class="n">pop_result</span><span class="p">()))</span>
                <span class="k">elif</span> <span class="n">leaf</span> <span class="o">==</span> <span class="n">AND_OPERATOR</span><span class="p">:</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> AND </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">pop_result</span><span class="p">(),</span> <span class="n">pop_result</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> OR </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">pop_result</span><span class="p">(),</span> <span class="n">pop_result</span><span class="p">()))</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">is_boolean</span><span class="p">(</span><span class="n">leaf</span><span class="p">):</span>
                <span class="n">push_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__leaf_to_sql</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="c1"># Get working variables</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">leaf</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">comodel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;comodel_name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

            <span class="c1"># ----------------------------------------</span>
            <span class="c1"># FIELD NOT FOUND</span>
            <span class="c1"># -&gt; from inherits&#39;d fields -&gt; work on the related model, and add</span>
            <span class="c1">#    a join condition</span>
            <span class="c1"># -&gt; (&#39;id&#39;, &#39;child_of&#39;, &#39;..&#39;) -&gt; use a &#39;to_ids&#39;</span>
            <span class="c1"># -&gt; but is one on the _log_access special fields, add directly to</span>
            <span class="c1">#    result</span>
            <span class="c1">#    TODO: make these fields explicitly available in self.columns instead!</span>
            <span class="c1"># -&gt; else: crash</span>
            <span class="c1"># ----------------------------------------</span>

            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">inherited</span><span class="p">:</span>
                <span class="n">parent_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">related_field</span><span class="o">.</span><span class="n">model_name</span><span class="p">]</span>
                <span class="n">parent_fname</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_inherits</span><span class="p">[</span><span class="n">parent_model</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span>
                <span class="n">parent_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">left_join</span><span class="p">(</span>
                    <span class="n">alias</span><span class="p">,</span> <span class="n">parent_fname</span><span class="p">,</span> <span class="n">parent_model</span><span class="o">.</span><span class="n">_table</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">parent_fname</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">push</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">parent_model</span><span class="p">,</span> <span class="n">parent_alias</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">left</span> <span class="o">==</span> <span class="s1">&#39;id&#39;</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">:</span>
                <span class="n">ids2</span> <span class="o">=</span> <span class="n">to_ids</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
                <span class="n">dom</span> <span class="o">=</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">left</span><span class="p">,</span> <span class="n">ids2</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dom_leaf</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">:</span>
                    <span class="n">push</span><span class="p">(</span><span class="n">dom_leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;properties&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrong path </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">operator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;not in&#39;</span><span class="p">,</span> <span class="s1">&#39;like&#39;</span><span class="p">,</span> <span class="s1">&#39;ilike&#39;</span><span class="p">,</span> <span class="s1">&#39;not like&#39;</span><span class="p">,</span> <span class="s1">&#39;not ilike&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrong search operator </span><span class="si">{</span><span class="n">operator</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">property_name</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">check_property_field_value_name</span><span class="p">(</span><span class="n">property_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">):</span>
                    <span class="c1"># check for boolean value but also for key existence</span>
                    <span class="k">if</span> <span class="n">right</span><span class="p">:</span>
                        <span class="c1"># inverse the condition</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">operator</span> <span class="o">=</span> <span class="s1">&#39;!=&#39;</span> <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span> <span class="k">else</span> <span class="s1">&#39;=&#39;</span>

                    <span class="n">sql_field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
                    <span class="n">sql_operator</span> <span class="o">=</span> <span class="n">SQL_OPERATORS</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                    <span class="n">sql_extra</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>  <span class="c1"># property == False</span>
                        <span class="n">sql_extra</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span>
                            <span class="s2">&quot;OR (</span><span class="si">%s</span><span class="s2"> IS NULL) OR NOT (</span><span class="si">%s</span><span class="s2"> ? </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                            <span class="n">sql_field</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">property_name</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                        <span class="s2">&quot;((</span><span class="si">%s</span><span class="s2"> -&gt; </span><span class="si">%s</span><span class="s2">) </span><span class="si">%s</span><span class="s2"> &#39;</span><span class="si">%s</span><span class="s2">&#39; </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                        <span class="n">sql_field</span><span class="p">,</span> <span class="n">property_name</span><span class="p">,</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">sql_extra</span><span class="p">,</span>
                    <span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;like&#39;</span><span class="p">,</span> <span class="s1">&#39;ilike&#39;</span><span class="p">,</span> <span class="s1">&#39;not like&#39;</span><span class="p">,</span> <span class="s1">&#39;not ilike&#39;</span><span class="p">):</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;%</span><span class="si">{</span><span class="n">pycompat</span><span class="o">.</span><span class="n">to_text</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s1">%&#39;</span>
                        <span class="n">unaccent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unaccent</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">unaccent</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

                    <span class="n">sql_field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;not in&#39;</span><span class="p">):</span>
                        <span class="n">sql_not</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;NOT&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;not in&#39;</span> <span class="k">else</span> <span class="n">SQL</span><span class="p">()</span>
                        <span class="n">sql_left</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> -&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">property_name</span><span class="p">)</span>  <span class="c1"># raw value</span>
                        <span class="n">sql_operator</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;&lt;@&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;@&gt;&#39;</span><span class="p">)</span>
                        <span class="n">sql_right</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
                        <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                            <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">) </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">))&quot;</span><span class="p">,</span>
                            <span class="n">sql_not</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_left</span><span class="p">),</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_right</span><span class="p">),</span>
                        <span class="p">))</span>

                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">sql_left</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> -&gt;&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">property_name</span><span class="p">)</span>  <span class="c1"># JSONified value</span>
                        <span class="n">sql_operator</span> <span class="o">=</span> <span class="n">SQL_OPERATORS</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                        <span class="n">sql_right</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                        <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                            <span class="s2">&quot;((</span><span class="si">%s</span><span class="s2">) </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">))&quot;</span><span class="p">,</span>
                            <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_left</span><span class="p">),</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_right</span><span class="p">),</span>
                        <span class="p">))</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sql_left</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> -&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">property_name</span><span class="p">)</span>  <span class="c1"># raw value</span>
                        <span class="n">sql_operator</span> <span class="o">=</span> <span class="n">SQL_OPERATORS</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                        <span class="n">sql_right</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
                        <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                            <span class="s2">&quot;((</span><span class="si">%s</span><span class="s2">) </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">))&quot;</span><span class="p">,</span>
                            <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_left</span><span class="p">),</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_right</span><span class="p">),</span>
                        <span class="p">))</span>

            <span class="c1"># ----------------------------------------</span>
            <span class="c1"># PATH SPOTTED</span>
            <span class="c1"># -&gt; many2one or one2many with _auto_join:</span>
            <span class="c1">#    - add a join, then jump into linked column: column.remaining on</span>
            <span class="c1">#      src_table is replaced by remaining on dst_table, and set for re-evaluation</span>
            <span class="c1">#    - if a domain is defined on the column, add it into evaluation</span>
            <span class="c1">#      on the relational table</span>
            <span class="c1"># -&gt; many2one, many2many, one2many: replace by an equivalent computed</span>
            <span class="c1">#    domain, given by recursively searching on the remaining of the path</span>
            <span class="c1"># -&gt; note: hack about columns.property should not be necessary anymore</span>
            <span class="c1">#    as after transforming the column, it will go through this loop once again</span>
            <span class="c1"># ----------------------------------------</span>

            <span class="k">elif</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">store</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;many2one&#39;</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">auto_join</span><span class="p">:</span>
                <span class="c1"># res_partner.state_id = res_partner__state_id.id</span>
                <span class="n">coalias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">left_join</span><span class="p">(</span>
                    <span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_table</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;not any&#39;</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="s1">&#39;!&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">right</span><span class="p">:</span>
                    <span class="n">push</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">comodel</span><span class="p">,</span> <span class="n">coalias</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">store</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;one2many&#39;</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">auto_join</span><span class="p">:</span>
                <span class="c1"># use a subquery bypassing access rules and business logic</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">right</span> <span class="o">+</span> <span class="n">field</span><span class="o">.</span><span class="n">get_domain_list</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
                <span class="n">query</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="o">**</span><span class="n">field</span><span class="o">.</span><span class="n">context</span><span class="p">)</span><span class="o">.</span><span class="n">_where_calc</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
                <span class="n">sql</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">subselect</span><span class="p">(</span>
                    <span class="n">comodel</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">comodel</span><span class="o">.</span><span class="n">_table</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">inverse_name</span><span class="p">,</span> <span class="n">query</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">push</span><span class="p">((</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">ANY_IN</span><span class="p">[</span><span class="n">operator</span><span class="p">],</span> <span class="n">sql</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">store</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">auto_join</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;auto_join attribute not supported on field </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">field</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">store</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;many2one&#39;</span><span class="p">:</span>
                <span class="n">right_ids</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">active_test</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;any&#39;</span><span class="p">:</span>
                    <span class="n">push</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">right_ids</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">dom_leaf</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;not in&#39;</span><span class="p">,</span> <span class="n">right_ids</span><span class="p">),</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
                        <span class="n">push</span><span class="p">(</span><span class="n">dom_leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

            <span class="c1"># Making search easier when there is a left operand as one2many or many2many</span>
            <span class="k">elif</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;not any&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">store</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;many2many&#39;</span><span class="p">,</span> <span class="s1">&#39;one2many&#39;</span><span class="p">):</span>
                <span class="n">right_ids</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="o">**</span><span class="n">field</span><span class="o">.</span><span class="n">context</span><span class="p">)</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="n">push</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">ANY_IN</span><span class="p">[</span><span class="n">operator</span><span class="p">],</span> <span class="n">right_ids</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">field</span><span class="o">.</span><span class="n">store</span><span class="p">:</span>
                <span class="c1"># Non-stored field should provide an implementation of search.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">field</span><span class="o">.</span><span class="n">search</span><span class="p">:</span>
                    <span class="c1"># field does not support search!</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Non-stored field </span><span class="si">%s</span><span class="s2"> cannot be searched.&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
                        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_stack</span><span class="p">()))</span>
                    <span class="c1"># Ignore it: generate a dummy leaf.</span>
                    <span class="n">domain</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Let the field generate a domain.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_search</span><span class="p">([(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)])</span>
                        <span class="n">operator</span> <span class="o">=</span> <span class="s1">&#39;in&#39;</span>
                    <span class="n">domain</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">determine_domain</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">_flush_search</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">domain_combine_anies</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
                    <span class="n">push</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># -------------------------------------------------</span>
            <span class="c1"># RELATIONAL FIELDS</span>
            <span class="c1"># -------------------------------------------------</span>

            <span class="c1"># Applying recursivity on field(one2many)</span>
            <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;one2many&#39;</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">:</span>
                <span class="n">ids2</span> <span class="o">=</span> <span class="n">to_ids</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">comodel</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
                    <span class="n">dom</span> <span class="o">=</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">left</span><span class="p">,</span> <span class="n">ids2</span><span class="p">,</span> <span class="n">comodel</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dom</span> <span class="o">=</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">ids2</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">left</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dom_leaf</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">:</span>
                    <span class="n">push</span><span class="p">(</span><span class="n">dom_leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;one2many&#39;</span><span class="p">:</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">get_domain_list</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
                <span class="n">inverse_field</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">inverse_name</span><span class="p">]</span>
                <span class="n">inverse_is_int</span> <span class="o">=</span> <span class="n">inverse_field</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="s1">&#39;many2one_reference&#39;</span><span class="p">)</span>
                <span class="n">unwrap_inverse</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">ids</span><span class="p">:</span> <span class="n">ids</span><span class="p">)</span> <span class="k">if</span> <span class="n">inverse_is_int</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">recs</span><span class="p">:</span> <span class="n">recs</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="c1"># determine ids2 in comodel</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">op2</span> <span class="o">=</span> <span class="p">(</span><span class="n">TERM_OPERATORS_NEGATION</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                               <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="k">else</span> <span class="n">operator</span><span class="p">)</span>
                        <span class="n">ids2</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_name_search</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">domain</span> <span class="ow">or</span> <span class="p">[],</span> <span class="n">op2</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                        <span class="n">ids2</span> <span class="o">=</span> <span class="n">right</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ids2</span> <span class="o">=</span> <span class="p">[</span><span class="n">right</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">inverse_is_int</span> <span class="ow">and</span> <span class="n">domain</span><span class="p">:</span>
                        <span class="n">ids2</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_search</span><span class="p">([(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">ids2</span><span class="p">)]</span> <span class="o">+</span> <span class="n">domain</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">inverse_field</span><span class="o">.</span><span class="n">store</span><span class="p">:</span>
                        <span class="c1"># In the condition, one must avoid subqueries to return</span>
                        <span class="c1"># NULL values, since it makes the IN test NULL instead</span>
                        <span class="c1"># of FALSE.  This may discard expected results, as for</span>
                        <span class="c1"># instance &quot;id NOT IN (42, NULL)&quot; is never TRUE.</span>
                        <span class="n">sql_in</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;NOT IN&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="k">else</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;IN&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids2</span><span class="p">,</span> <span class="n">Query</span><span class="p">):</span>
                            <span class="n">ids2</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">ids2</span><span class="p">)</span><span class="o">.</span><span class="n">_as_query</span><span class="p">(</span><span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">sql_inverse</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">ids2</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="n">inverse_field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ids2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">inverse_field</span><span class="o">.</span><span class="n">required</span><span class="p">:</span>
                            <span class="n">ids2</span><span class="o">.</span><span class="n">add_where</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> IS NOT NULL&quot;</span><span class="p">,</span> <span class="n">sql_inverse</span><span class="p">))</span>
                        <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                            <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                            <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">),</span>
                            <span class="n">sql_in</span><span class="p">,</span>
                            <span class="n">ids2</span><span class="o">.</span><span class="n">subselect</span><span class="p">(</span><span class="n">sql_inverse</span><span class="p">),</span>
                        <span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># determine ids1 in model related to ids2</span>
                        <span class="n">recs</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">ids2</span><span class="p">)</span><span class="o">.</span><span class="n">sudo</span><span class="p">()</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">prefetch_fields</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">ids1</span> <span class="o">=</span> <span class="n">unwrap_inverse</span><span class="p">(</span><span class="n">recs</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="n">inverse_field</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="c1"># rewrite condition in terms of ids1</span>
                        <span class="n">op1</span> <span class="o">=</span> <span class="s1">&#39;not in&#39;</span> <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="k">else</span> <span class="s1">&#39;in&#39;</span>
                        <span class="n">push</span><span class="p">((</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">ids1</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">inverse_field</span><span class="o">.</span><span class="n">store</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">inverse_is_int</span> <span class="ow">and</span> <span class="n">domain</span><span class="p">):</span>
                        <span class="c1"># rewrite condition to match records with/without lines</span>
                        <span class="n">sub_op</span> <span class="o">=</span> <span class="s1">&#39;in&#39;</span> <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="k">else</span> <span class="s1">&#39;not in&#39;</span>
                        <span class="n">comodel_domain</span> <span class="o">=</span> <span class="p">[(</span><span class="n">inverse_field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
                        <span class="n">query</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">active_test</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_where_calc</span><span class="p">(</span><span class="n">comodel_domain</span><span class="p">)</span>
                        <span class="n">sql_inverse</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="n">inverse_field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
                        <span class="n">sql</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">subselect</span><span class="p">(</span><span class="n">sql_inverse</span><span class="p">)</span>
                        <span class="n">push</span><span class="p">((</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">sub_op</span><span class="p">,</span> <span class="n">sql</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">comodel_domain</span> <span class="o">=</span> <span class="p">[(</span><span class="n">inverse_field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="n">inverse_is_int</span> <span class="ow">and</span> <span class="n">domain</span><span class="p">:</span>
                            <span class="n">comodel_domain</span> <span class="o">+=</span> <span class="n">domain</span>
                        <span class="n">recs</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">comodel_domain</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sudo</span><span class="p">()</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">prefetch_fields</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="c1"># determine ids1 = records with lines</span>
                        <span class="n">ids1</span> <span class="o">=</span> <span class="n">unwrap_inverse</span><span class="p">(</span><span class="n">recs</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="n">inverse_field</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="c1"># rewrite condition to match records with/without lines</span>
                        <span class="n">op1</span> <span class="o">=</span> <span class="s1">&#39;in&#39;</span> <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="k">else</span> <span class="s1">&#39;not in&#39;</span>
                        <span class="n">push</span><span class="p">((</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">ids1</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;many2many&#39;</span><span class="p">:</span>
                <span class="n">rel_table</span><span class="p">,</span> <span class="n">rel_id1</span><span class="p">,</span> <span class="n">rel_id2</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">relation</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">column1</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">column2</span>

                <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">:</span>
                    <span class="c1"># determine ids2 in comodel</span>
                    <span class="n">ids2</span> <span class="o">=</span> <span class="n">to_ids</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">comodel</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
                    <span class="n">domain</span> <span class="o">=</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">ids2</span><span class="p">,</span> <span class="n">comodel</span><span class="p">)</span>
                    <span class="n">ids2</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>

                    <span class="c1"># rewrite condition in terms of ids2</span>
                    <span class="k">if</span> <span class="n">comodel</span> <span class="o">==</span> <span class="n">model</span><span class="p">:</span>
                        <span class="n">push</span><span class="p">((</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">ids2</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rel_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">make_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                            <span class="s2">&quot;EXISTS (SELECT 1 FROM </span><span class="si">%s</span><span class="s2"> AS </span><span class="si">%s</span><span class="s2"> WHERE </span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2"> AND </span><span class="si">%s</span><span class="s2"> IN </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                            <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_table</span><span class="p">),</span>
                            <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_alias</span><span class="p">),</span>
                            <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_alias</span><span class="p">,</span> <span class="n">rel_id1</span><span class="p">),</span>
                            <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">),</span>
                            <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_alias</span><span class="p">,</span> <span class="n">rel_id2</span><span class="p">),</span>
                            <span class="nb">tuple</span><span class="p">(</span><span class="n">ids2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
                        <span class="p">))</span>

                <span class="k">elif</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="c1"># determine ids2 in comodel</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">domain</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">get_domain_list</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
                        <span class="n">op2</span> <span class="o">=</span> <span class="p">(</span><span class="n">TERM_OPERATORS_NEGATION</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                               <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="k">else</span> <span class="n">operator</span><span class="p">)</span>
                        <span class="n">ids2</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">_name_search</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">domain</span> <span class="ow">or</span> <span class="p">[],</span> <span class="n">op2</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                        <span class="n">ids2</span> <span class="o">=</span> <span class="n">right</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ids2</span> <span class="o">=</span> <span class="p">[</span><span class="n">right</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids2</span><span class="p">,</span> <span class="n">Query</span><span class="p">):</span>
                        <span class="c1"># rewrite condition in terms of ids2</span>
                        <span class="n">sql_ids2</span> <span class="o">=</span> <span class="n">ids2</span><span class="o">.</span><span class="n">subselect</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># rewrite condition in terms of ids2</span>
                        <span class="n">sql_ids2</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">ids2</span> <span class="k">if</span> <span class="n">it</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="kc">None</span><span class="p">,))</span>

                    <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span><span class="p">:</span>
                        <span class="n">sql_exists</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;NOT EXISTS&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sql_exists</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;EXISTS&#39;</span><span class="p">)</span>

                    <span class="n">rel_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">make_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (SELECT 1 FROM </span><span class="si">%s</span><span class="s2"> AS </span><span class="si">%s</span><span class="s2"> WHERE </span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2"> AND </span><span class="si">%s</span><span class="s2"> IN </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                        <span class="n">sql_exists</span><span class="p">,</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_table</span><span class="p">),</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_alias</span><span class="p">),</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_alias</span><span class="p">,</span> <span class="n">rel_id1</span><span class="p">),</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">),</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_alias</span><span class="p">,</span> <span class="n">rel_id2</span><span class="p">),</span>
                        <span class="n">sql_ids2</span><span class="p">,</span>
                    <span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># rewrite condition to match records with/without relations</span>
                    <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span><span class="p">:</span>
                        <span class="n">sql_exists</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;EXISTS&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sql_exists</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;NOT EXISTS&#39;</span><span class="p">)</span>
                    <span class="n">rel_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">make_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (SELECT 1 FROM </span><span class="si">%s</span><span class="s2"> AS </span><span class="si">%s</span><span class="s2"> WHERE </span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                        <span class="n">sql_exists</span><span class="p">,</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_table</span><span class="p">),</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_alias</span><span class="p">),</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">rel_alias</span><span class="p">,</span> <span class="n">rel_id1</span><span class="p">),</span>
                        <span class="n">SQL</span><span class="o">.</span><span class="n">identifier</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">),</span>
                    <span class="p">))</span>

            <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;many2one&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">:</span>
                    <span class="n">ids2</span> <span class="o">=</span> <span class="n">to_ids</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">comodel</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
                        <span class="n">dom</span> <span class="o">=</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">left</span><span class="p">,</span> <span class="n">ids2</span><span class="p">,</span> <span class="n">comodel</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">comodel_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dom</span> <span class="o">=</span> <span class="n">HIERARCHY_FUNCS</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">ids2</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">left</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">dom_leaf</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">:</span>
                        <span class="n">push</span><span class="p">(</span><span class="n">dom_leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

                <span class="k">elif</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">right</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">right</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1"># resolve string-based m2o criterion into IDs subqueries</span>

                    <span class="c1"># Special treatment to ill-formed domains</span>
                    <span class="n">operator</span> <span class="o">=</span> <span class="s1">&#39;in&#39;</span> <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">operator</span>
                    <span class="n">dict_op</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;not in&#39;</span><span class="p">:</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="s1">&#39;not in&#39;</span><span class="p">}</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;not in&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">):</span>
                        <span class="n">operator</span> <span class="o">=</span> <span class="n">dict_op</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">):</span>  <span class="c1"># for domain (FIELD,&#39;=&#39;,[&#39;value1&#39;,&#39;value2&#39;])</span>
                        <span class="n">operator</span> <span class="o">=</span> <span class="n">dict_op</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                    <span class="n">res_ids</span> <span class="o">=</span> <span class="n">comodel</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">active_test</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_name_search</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">[],</span> <span class="n">operator</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">dom_leaf</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">res_ids</span><span class="p">),</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
                            <span class="n">push</span><span class="p">(</span><span class="n">dom_leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">push</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">res_ids</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># right == [] or right == False and all other cases are handled by __leaf_to_sql()</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__leaf_to_sql</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">))</span>

            <span class="c1"># -------------------------------------------------</span>
            <span class="c1"># BINARY FIELDS STORED IN ATTACHMENT</span>
            <span class="c1"># -&gt; check for null only</span>
            <span class="c1"># -------------------------------------------------</span>

            <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">attachment</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                    <span class="n">sub_op</span> <span class="o">=</span> <span class="s1">&#39;in&#39;</span> <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="k">else</span> <span class="s1">&#39;not in&#39;</span>
                    <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span>
                        <span class="s2">&quot;(SELECT res_id FROM ir_attachment WHERE res_model = </span><span class="si">%s</span><span class="s2"> AND res_field = </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                        <span class="n">model</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">push</span><span class="p">((</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">sub_op</span><span class="p">,</span> <span class="n">sql</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Binary field &#39;</span><span class="si">%s</span><span class="s2">&#39; stored in attachment: ignore </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                  <span class="n">field</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">reprlib</span><span class="o">.</span><span class="n">repr</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
                    <span class="n">push</span><span class="p">(</span><span class="n">TRUE_LEAF</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

            <span class="c1"># -------------------------------------------------</span>
            <span class="c1"># OTHER FIELDS</span>
            <span class="c1"># -&gt; datetime fields: manage time part of the datetime</span>
            <span class="c1">#    column when it is not there</span>
            <span class="c1"># -&gt; manage translatable fields</span>
            <span class="c1"># -------------------------------------------------</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;datetime&#39;</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">):</span>
                            <span class="n">right</span> <span class="o">+=</span> <span class="s1">&#39; 23:59:59&#39;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">right</span> <span class="o">+=</span> <span class="s1">&#39; 00:00:00&#39;</span>
                        <span class="n">push</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">):</span>
                            <span class="n">right</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">right</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
                        <span class="n">push</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">push_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__leaf_to_sql</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">))</span>

                <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">translate</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">==</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">model_raw_trans</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">prefetch_langs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">sql_field</span> <span class="o">=</span> <span class="n">model_raw_trans</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
                    <span class="n">sql_operator</span> <span class="o">=</span> <span class="n">SQL_OPERATORS</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                    <span class="n">sql_exprs</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="n">need_wildcard</span> <span class="o">=</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;like&#39;</span><span class="p">,</span> <span class="s1">&#39;ilike&#39;</span><span class="p">,</span> <span class="s1">&#39;not like&#39;</span><span class="p">,</span> <span class="s1">&#39;not ilike&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">need_wildcard</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">convert_to_column</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">adapted</span><span class="p">[</span><span class="s1">&#39;en_US&#39;</span><span class="p">]</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">need_wildcard</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">right</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span><span class="p">):</span>
                        <span class="n">sql_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> IS NULL OR&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">))</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_trigram</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="s1">&#39;trigram&#39;</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;like&#39;</span><span class="p">,</span> <span class="s1">&#39;ilike&#39;</span><span class="p">,</span> <span class="s1">&#39;=like&#39;</span><span class="p">,</span> <span class="s1">&#39;=ilike&#39;</span><span class="p">):</span>
                        <span class="c1"># a prefilter using trigram index to speed up &#39;=&#39;, &#39;like&#39;, &#39;ilike&#39;</span>
                        <span class="c1"># &#39;!=&#39;, &#39;&lt;=&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;=&#39;, &#39;in&#39;, &#39;not in&#39;, &#39;not like&#39;, &#39;not ilike&#39; cannot use this trick</span>
                        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
                            <span class="n">_right</span> <span class="o">=</span> <span class="n">value_to_translated_trigram_pattern</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">_right</span> <span class="o">=</span> <span class="n">pattern_to_translated_trigram_pattern</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">_right</span> <span class="o">!=</span> <span class="s1">&#39;%&#39;</span><span class="p">:</span>
                            <span class="n">_unaccent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unaccent</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                            <span class="n">_left</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;jsonb_path_query_array(</span><span class="si">%s</span><span class="s2">, &#39;$.*&#39;)::text&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>
                            <span class="n">_sql_operator</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;LIKE&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span> <span class="k">else</span> <span class="n">sql_operator</span>
                            <span class="n">sql_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> AND&quot;</span><span class="p">,</span>
                                <span class="n">_unaccent</span><span class="p">(</span><span class="n">_left</span><span class="p">),</span>
                                <span class="n">_sql_operator</span><span class="p">,</span>
                                <span class="n">_unaccent</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_right</span><span class="p">))</span>
                            <span class="p">))</span>

                    <span class="n">unaccent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unaccent</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;ilike&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
                    <span class="n">sql_left</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">need_wildcard</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;%</span><span class="si">{</span><span class="n">right</span><span class="si">}</span><span class="s1">%&#39;</span>

                    <span class="n">sql_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_left</span><span class="p">),</span>
                        <span class="n">sql_operator</span><span class="p">,</span>
                        <span class="n">unaccent</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">)),</span>
                    <span class="p">))</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sql_exprs</span><span class="p">)))</span>

                <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">translate</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;not in&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">==</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">model_raw_trans</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">prefetch_langs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">sql_field</span> <span class="o">=</span> <span class="n">model_raw_trans</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
                    <span class="n">sql_operator</span> <span class="o">=</span> <span class="n">SQL_OPERATORS</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">right</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">check_null</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">convert_to_column</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">adapted</span><span class="p">[</span><span class="s1">&#39;en_US&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
                        <span class="n">langs</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">get_translation_fallback_langs</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
                        <span class="n">sql_left_langs</span> <span class="o">=</span> <span class="p">[</span><span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-&gt;&gt;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">lang</span><span class="p">)</span> <span class="k">for</span> <span class="n">lang</span> <span class="ow">in</span> <span class="n">langs</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sql_left_langs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">sql_left</span> <span class="o">=</span> <span class="n">sql_left_langs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sql_left</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;COALESCE(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sql_left_langs</span><span class="p">))</span>
                        <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sql_left</span><span class="p">,</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># The case for (left, &#39;in&#39;, []) or (left, &#39;not in&#39;, []).</span>
                        <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;FALSE&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span> <span class="k">else</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;TRUE&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span> <span class="ow">and</span> <span class="n">check_null</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;not in&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">check_null</span><span class="p">):</span>
                        <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> OR </span><span class="si">%s</span><span class="s2"> IS NULL)&quot;</span><span class="p">,</span> <span class="n">sql</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;not in&#39;</span> <span class="ow">and</span> <span class="n">check_null</span><span class="p">:</span>
                        <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> AND </span><span class="si">%s</span><span class="s2"> IS NOT NULL)&quot;</span><span class="p">,</span> <span class="n">sql</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>  <span class="c1"># needed only for TRUE.</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">push_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__leaf_to_sql</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">))</span>

        <span class="c1"># ----------------------------------------</span>
        <span class="c1"># END OF PARSING FULL DOMAIN</span>
        <span class="c1"># -&gt; put result in self.result and self.query</span>
        <span class="c1"># ----------------------------------------</span>

        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">add_where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__leaf_to_sql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SQL</span><span class="p">:</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">leaf</span>

        <span class="c1"># final sanity checks - should never fail</span>
        <span class="k">assert</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="n">TERM_OPERATORS</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;inselect&#39;</span><span class="p">,</span> <span class="s1">&#39;not inselect&#39;</span><span class="p">)),</span> \
            <span class="s2">&quot;Invalid operator </span><span class="si">%r</span><span class="s2"> in domain term </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="p">(</span><span class="n">TRUE_LEAF</span><span class="p">,</span> <span class="n">FALSE_LEAF</span><span class="p">)</span> <span class="ow">or</span> <span class="n">left</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="p">,</span> \
            <span class="s2">&quot;Invalid field </span><span class="si">%r</span><span class="s2"> in domain term </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">BaseModel</span><span class="p">),</span> \
            <span class="s2">&quot;Invalid value </span><span class="si">%r</span><span class="s2"> in domain term </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">leaf</span> <span class="o">==</span> <span class="n">TRUE_LEAF</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;TRUE&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">leaf</span> <span class="o">==</span> <span class="n">FALSE_LEAF</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;FALSE&quot;</span><span class="p">)</span>

        <span class="n">field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
        <span class="n">sql_field</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_field_to_sql</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;inselect&#39;</span><span class="p">:</span>
            <span class="n">subquery</span><span class="p">,</span> <span class="n">subparams</span> <span class="o">=</span> <span class="n">right</span>
            <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> IN (</span><span class="si">%s</span><span class="s2">))&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">SQL</span><span class="p">(</span><span class="n">subquery</span><span class="p">,</span> <span class="o">*</span><span class="n">subparams</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;not inselect&#39;</span><span class="p">:</span>
            <span class="n">subquery</span><span class="p">,</span> <span class="n">subparams</span> <span class="o">=</span> <span class="n">right</span>
            <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> NOT IN (</span><span class="si">%s</span><span class="s2">))&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">SQL</span><span class="p">(</span><span class="n">subquery</span><span class="p">,</span> <span class="o">*</span><span class="n">subparams</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;=?&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># &#39;=?&#39; is a short-circuit that makes the term TRUE if right is None or False</span>
                <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;TRUE&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># &#39;=?&#39; behaves like &#39;=&#39; in other cases</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__leaf_to_sql</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

        <span class="n">sql_operator</span> <span class="o">=</span> <span class="n">SQL_OPERATORS</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;not in&#39;</span><span class="p">):</span>
            <span class="c1"># Two cases: right is a boolean or a list. The boolean case is an</span>
            <span class="c1"># abuse and handled for backward compatibility.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The domain term &#39;</span><span class="si">%s</span><span class="s2">&#39; should use the &#39;=&#39; or &#39;!=&#39; operator.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">leaf</span><span class="p">,))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span> <span class="ow">and</span> <span class="n">right</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;not in&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> IS NOT NULL)&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> IS NULL)&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">SQL</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Query</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">subselect</span><span class="p">())</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;boolean&quot;</span><span class="p">:</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">right</span><span class="p">]</span>
                    <span class="n">check_null</span> <span class="o">=</span> <span class="kc">False</span> <span class="ow">in</span> <span class="n">right</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">it</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">right</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">check_null</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">left</span> <span class="o">!=</span> <span class="s1">&#39;id&#39;</span><span class="p">:</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">convert_to_column</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
                    <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The case for (left, &#39;in&#39;, []) or (left, &#39;not in&#39;, []).</span>
                    <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;FALSE&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span> <span class="k">else</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;TRUE&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span> <span class="ow">and</span> <span class="n">check_null</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;not in&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">check_null</span><span class="p">):</span>
                    <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> OR </span><span class="si">%s</span><span class="s2"> IS NULL)&quot;</span><span class="p">,</span> <span class="n">sql</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;not in&#39;</span> <span class="ow">and</span> <span class="n">check_null</span><span class="p">:</span>
                    <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> AND </span><span class="si">%s</span><span class="s2"> IS NOT NULL)&quot;</span><span class="p">,</span> <span class="n">sql</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>  <span class="c1"># needed only for TRUE</span>
                <span class="k">return</span> <span class="n">sql</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Must not happen</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid domain term </span><span class="si">{</span><span class="n">leaf</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;boolean&#39;</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">right</span><span class="p">)</span> <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span> <span class="k">else</span> <span class="n">right</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> = TRUE)&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> IS NULL OR </span><span class="si">%s</span><span class="s2"> = FALSE)&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> IS NULL&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;!=&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> IS NOT NULL&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>

        <span class="c1"># general case</span>
        <span class="n">need_wildcard</span> <span class="o">=</span> <span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;like&#39;</span><span class="p">,</span> <span class="s1">&#39;ilike&#39;</span><span class="p">,</span> <span class="s1">&#39;not like&#39;</span><span class="p">,</span> <span class="s1">&#39;not ilike&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">SQL</span><span class="p">):</span>
            <span class="n">sql_right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="k">elif</span> <span class="n">need_wildcard</span><span class="p">:</span>
            <span class="n">sql_right</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;%</span><span class="si">{</span><span class="n">pycompat</span><span class="o">.</span><span class="n">to_text</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sql_right</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">convert_to_column</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="n">sql_left</span> <span class="o">=</span> <span class="n">sql_field</span>
        <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;like&#39;</span><span class="p">):</span>
            <span class="n">sql_left</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">::text&quot;</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;ilike&#39;</span><span class="p">):</span>
            <span class="n">unaccent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unaccent</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="n">sql_left</span> <span class="o">=</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_left</span><span class="p">)</span>
            <span class="n">sql_right</span> <span class="o">=</span> <span class="n">unaccent</span><span class="p">(</span><span class="n">sql_right</span><span class="p">)</span>

        <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">sql_left</span><span class="p">,</span> <span class="n">sql_operator</span><span class="p">,</span> <span class="n">sql_right</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">need_wildcard</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">right</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">NEGATIVE_TERM_OPERATORS</span><span class="p">):</span>
            <span class="n">sql</span> <span class="o">=</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> OR </span><span class="si">%s</span><span class="s2"> IS NULL)&quot;</span><span class="p">,</span> <span class="n">sql</span><span class="p">,</span> <span class="n">sql_field</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sql</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Amr.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>